<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Player Model</title>
  <style>
    body { margin: 0; overflow: hidden; background: #101114; }
    canvas { display: block; }
    #hud {
      position: absolute;
      top: 12px;
      left: 12px;
      z-index: 10;
      color: #e6e6e6;
      background: rgba(0, 0, 0, 0.6);
      padding: 10px 12px;
      border-radius: 8px;
      font: 12px/1.4 "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
      width: 320px;
    }
    #hud code {
      font-family: Consolas, "Courier New", monospace;
      font-size: 12px;
    }
    .hint { color: #bbb; margin-top: 6px; }
  </style>
  <script type="importmap">
  {
    "imports": {
      "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
      "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
    }
  }
  </script>
</head>
<body>
  <div id="hud">
    <div id="status">Status: idle</div>
    <div id="controlInfo">Control target: none</div>
    <div class="hint">1/2 shoulders, 3/4 hands, arrows/PageUp/PageDown adjust, W/S = right hand up/down, Shift faster, R reset bone</div>
    <div>Loading <code>./3d_person.glb</code></div>
    <div>Single-file GLB (no external textures).</div>
  </div>

<script type="module">
import * as THREE from "three";
import { GLTFLoader } from "three/addons/loaders/GLTFLoader.js";
import { OrbitControls } from "three/addons/controls/OrbitControls.js";

const scene = new THREE.Scene();
scene.background = new THREE.Color(0x101114);

const camera = new THREE.PerspectiveCamera(55, window.innerWidth / window.innerHeight, 0.1, 2000);
camera.position.set(0, 120, 220);

const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.setPixelRatio(window.devicePixelRatio);
renderer.outputColorSpace = THREE.SRGBColorSpace;
renderer.toneMapping = THREE.ACESFilmicToneMapping;
renderer.toneMappingExposure = 1.0;
document.body.appendChild(renderer.domElement);

const controls = new OrbitControls(camera, renderer.domElement);
controls.enableDamping = true;
controls.target.set(0, 90, 0);
controls.update();

scene.add(new THREE.HemisphereLight(0xffffff, 0x1b1f2a, 0.6));
const dir = new THREE.DirectionalLight(0xffffff, 1.0);
dir.position.set(200, 300, 150);
scene.add(dir);

const axes = new THREE.AxesHelper(120);
scene.add(axes);

const statusEl = document.getElementById("status");
const controlInfoEl = document.getElementById("controlInfo");
const markerBaseRadius = 0.5;
const markerGeometry = new THREE.SphereGeometry(markerBaseRadius, 14, 14);
const markerMaterials = {
  shoulderL: new THREE.MeshBasicMaterial({ color: 0xff6ad5, depthTest: false }),
  shoulderR: new THREE.MeshBasicMaterial({ color: 0x56b6ff, depthTest: false }),
  handL: new THREE.MeshBasicMaterial({ color: 0x6cffb1, depthTest: false }),
  handR: new THREE.MeshBasicMaterial({ color: 0xffc36a, depthTest: false })
};
const controlDefs = [
  { key: "shoulderL", label: "shoulder L", type: "shoulder", side: "left", keywords: ["shoulder", "clavicle", "upperarm", "upper_arm"], fallback: { dx: -0.22, dy: 0.78, dz: 0 }, radius: 0.18 },
  { key: "shoulderR", label: "shoulder R", type: "shoulder", side: "right", keywords: ["shoulder", "clavicle", "upperarm", "upper_arm"], fallback: { dx: 0.22, dy: 0.78, dz: 0 }, radius: 0.18 },
  { key: "handL", label: "hand L", type: "hand", side: "left", keywords: ["hand", "wrist"], fallback: { dx: -0.45, dy: 0.52, dz: 0 }, radius: 0.14 },
  { key: "handR", label: "hand R", type: "hand", side: "right", keywords: ["hand", "wrist"], fallback: { dx: 0.45, dy: 0.52, dz: 0 }, radius: 0.14 }
];
const controlTargets = {};
let controlStep = 1;
let activeTargetKey = "handR";
const rotationStep = 0.08;
const modelScale = 3.25;

function setStatus(message) {
  statusEl.textContent = `Status: ${message}`;
}

function updateControlInfo(note) {
  if (!controlInfoEl) return;
  const target = controlTargets[activeTargetKey];
  if (!target || !target.marker) {
    controlInfoEl.textContent = "Control target: none";
    return;
  }
  const p = new THREE.Vector3();
  target.marker.getWorldPosition(p);
  const mode = target.bone ? "bone" : "marker";
  const base = `Control target (${target.label}, ${mode}): (${p.x.toFixed(1)}, ${p.y.toFixed(1)}, ${p.z.toFixed(1)})`;
  controlInfoEl.textContent = note ? `${base} ${note}` : base;
}

function frameModel(model) {
  model.updateMatrixWorld(true);
  const box = new THREE.Box3().setFromObject(model);
  const size = new THREE.Vector3();
  const center = new THREE.Vector3();
  box.getSize(size);
  box.getCenter(center);

  model.position.sub(center);

  model.updateMatrixWorld(true);
  const box2 = new THREE.Box3().setFromObject(model);
  const size2 = new THREE.Vector3();
  const center2 = new THREE.Vector3();
  box2.getSize(size2);
  box2.getCenter(center2);

  controls.target.copy(center2);
  const maxDim = Math.max(size2.x, size2.y, size2.z);
  const fov = THREE.MathUtils.degToRad(camera.fov);
  let dist = maxDim / (2 * Math.tan(fov / 2));
  dist = Math.max(dist * 1.4, maxDim * 1.2);
  camera.position.copy(center2).add(new THREE.Vector3(dist, dist * 0.6, dist));
  camera.near = Math.max(0.1, dist / 100);
  camera.far = dist * 10;
  camera.updateProjectionMatrix();
  controls.update();
}

function collectBones(root) {
  const bones = [];
  const seen = new Set();
  root.traverse((obj) => {
    if (obj.isSkinnedMesh && obj.skeleton) {
      obj.skeleton.bones.forEach((bone) => {
        if (!seen.has(bone)) {
          seen.add(bone);
          bones.push(bone);
        }
      });
    }
    if (obj.isBone && !seen.has(obj)) {
      seen.add(obj);
      bones.push(obj);
    }
  });
  return bones;
}

function sideFromName(name) {
  const n = name.toLowerCase();
  const isLeft = /(\bleft\b|_l\b|\.l\b|^l_|_l_|:l\b)/.test(n);
  const isRight = /(\bright\b|_r\b|\.r\b|^r_|_r_|:r\b)/.test(n);
  if (isLeft && !isRight) return "left";
  if (isRight && !isLeft) return "right";
  return null;
}

function pickBone(bones, keywords, side) {
  const excludes = ["twist", "end", "tip", "finger", "thumb", "index", "middle", "ring", "pinky"];
  const candidates = bones.filter((bone) => {
    const name = (bone.name || "").toLowerCase();
    if (!name) return false;
    if (excludes.some((ex) => name.includes(ex))) return false;
    if (!keywords.some((key) => name.includes(key))) return false;
    const detected = sideFromName(name);
    return detected ? detected === side : true;
  });
  candidates.sort((a, b) => (a.name || "").length - (b.name || "").length);
  return candidates[0] || null;
}

function createMarker(def) {
  const mesh = new THREE.Mesh(markerGeometry, markerMaterials[def.key]);
  mesh.name = `Marker_${def.key}`;
  mesh.renderOrder = 10;
  return mesh;
}

function setMarkerWorldRadius(markerMesh, targetRadius, referenceObject) {
  const scale = new THREE.Vector3();
  referenceObject.getWorldScale(scale);
  const denom = Math.max(1e-6, scale.x);
  markerMesh.scale.setScalar(targetRadius / denom / markerBaseRadius);
}

function setupControlMarkers(model) {
  controlDefs.forEach((def) => {
    const prev = controlTargets[def.key];
    if (prev && prev.marker && prev.marker.parent) {
      prev.marker.parent.remove(prev.marker);
    }
  });

  const bones = collectBones(model);
  const box = new THREE.Box3().setFromObject(model);
  const size = new THREE.Vector3();
  const center = new THREE.Vector3();
  box.getSize(size);
  box.getCenter(center);
  controlStep = Math.max(0.2, size.y * 0.01);

  controlDefs.forEach((def) => {
    const marker = createMarker(def);
    const bone = pickBone(bones, def.keywords, def.side);
    if (bone) {
      bone.add(marker);
      marker.position.set(0, 0, 0);
      setMarkerWorldRadius(marker, def.radius, bone);
    } else {
      const fallback = def.fallback;
      const worldPos = new THREE.Vector3(
        center.x + fallback.dx * size.x,
        box.min.y + fallback.dy * size.y,
        center.z + fallback.dz * size.z
      );
      marker.position.copy(model.worldToLocal(worldPos));
      model.add(marker);
      setMarkerWorldRadius(marker, def.radius, model);
    }
    controlTargets[def.key] = {
      key: def.key,
      label: def.label,
      bone,
      marker
    };
  });
  updateControlInfo("(ready)");
}

const loader = new GLTFLoader();
setStatus("loading 3d_person.glb");
loader.load(
  "./3d_person.glb",
  (gltf) => {
    gltf.scene.scale.setScalar(modelScale);
    scene.add(gltf.scene);
    frameModel(gltf.scene);
    setupControlMarkers(gltf.scene);
    setStatus("loaded 3d_person.glb");
  },
  undefined,
  (err) => {
    console.error("Failed to load 3d_person.glb", err);
    setStatus("failed to load 3d_person.glb");
  }
);

function onResize() {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
}
window.addEventListener("resize", onResize);

window.addEventListener("keydown", (e) => {
  const active = document.activeElement;
  if (active && (active.tagName === "INPUT" || active.tagName === "TEXTAREA")) return;

  const lowerKey = e.key.toLowerCase();
  if (lowerKey === "w" || lowerKey === "s") {
    const direct = controlTargets.handR;
    if (!direct || !direct.marker) return;
    activeTargetKey = "handR";
    const step = e.shiftKey ? controlStep * 5 : controlStep;
    const rot = e.shiftKey ? rotationStep * 2 : rotationStep;
    const dir = lowerKey === "w" ? 1 : -1;
    if (direct.bone) {
      direct.bone.rotation.x += rot * dir;
    } else {
      direct.marker.position.y += step * dir;
    }
    e.preventDefault();
    updateControlInfo(direct.bone ? "(rotated)" : "(moved)");
    return;
  }

  const selectMap = {
    "1": "shoulderL",
    "2": "shoulderR",
    "3": "handL",
    "4": "handR"
  };
  if (selectMap[e.key]) {
    activeTargetKey = selectMap[e.key];
    updateControlInfo("(selected)");
    return;
  }

  const target = controlTargets[activeTargetKey];
  if (!target || !target.marker) return;

  const step = e.shiftKey ? controlStep * 5 : controlStep;
  const rot = e.shiftKey ? rotationStep * 2 : rotationStep;
  let moved = true;

  if (target.bone) {
    switch (e.key) {
      case "ArrowLeft":
        target.bone.rotation.z += rot;
        break;
      case "ArrowRight":
        target.bone.rotation.z -= rot;
        break;
      case "ArrowUp":
        target.bone.rotation.x += rot;
        break;
      case "ArrowDown":
        target.bone.rotation.x -= rot;
        break;
      case "PageUp":
        target.bone.rotation.y += rot;
        break;
      case "PageDown":
        target.bone.rotation.y -= rot;
        break;
      case "r":
      case "R":
        target.bone.rotation.set(0, 0, 0);
        break;
      default:
        moved = false;
    }
  } else {
    switch (e.key) {
      case "ArrowLeft":
        target.marker.position.x -= step;
        break;
      case "ArrowRight":
        target.marker.position.x += step;
        break;
      case "ArrowUp":
        target.marker.position.z -= step;
        break;
      case "ArrowDown":
        target.marker.position.z += step;
        break;
      case "PageUp":
        target.marker.position.y += step;
        break;
      case "PageDown":
        target.marker.position.y -= step;
        break;
      default:
        moved = false;
    }
  }

  if (moved) {
    e.preventDefault();
    updateControlInfo(target.bone ? "(rotated)" : "(moved)");
  }
});

function animate() {
  requestAnimationFrame(animate);
  controls.update();
  renderer.render(scene, camera);
}
animate();
</script>
</body>
</html>
